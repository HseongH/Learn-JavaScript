# 데이터 타입

## 1. 데이터 타입의 종류

기본형과 참조형으로 나뉜다.

### 1.1 기본형

할당이나 연산시 값이 담긴 주소값을 바로 복제한다. 불변형이다.

- Number(숫자)
- String(문자)
- Boolean
- null
- undefined
- Symbol

***

### 1.2 참조형

할당이나 연산시 값이 담긴 주솟값들로 이루어진 묶음을 가리키는 주솟값을 복제한다.

- Object(객체)
    - Array(배열)
    - function(함수)
    - Date
    - RegExp(정규식)
    - Map
    - WeakMap
    - Set
    - WeakSet

***

## 2. 데이터 타입 배경지식

### 2.1 메모리와 데이터

- 컴퓨터는 모든 데이터를 0 또는 1로 처리, 0 또는 1로 처리할 수 있는 하나의 메모리 조각을 비트(bit)라 한다.
- 하나의 비트 단위로 데이터의 위치를 찾는 것보다는 몇 개의 비트를 묶어 데이터를 검색하는 것이 더 효율적이다.
    - 데이터를 효율적으로 찾을 수 있도록 8개의 비트를 하나의 묶음으로 만들었는데 이것이 바이트(byte)이다.
        - 바이트는 256개의 값을 표현할 수 있다.

***

### 2.2 변수와 식별자

- 변수: 변할 수 있는 무언가(데이터)가 담길 수 있는 공간 또는 그릇
- 식별자: 데이터를 식별하는 데 사용하는 이름, 즉 변수명

***

### 2.3 변수 선언

```javascript
var a = 1;
```

1. 메모리에서 빈 공간(@1003)을 하나 확보한다.
2. @1003에 변수의 식별자를 a로 지정한다.
3. 데이터를 저장할 빈 공간(@5003)을 하나 확보한다.
4. @5003에 변수의 값을 저장한다.
5. a라는 식별자를 검색한다.
6. @1003의 공간에 값이 저장된 주소 @5003을 저장한다.

#### 장점

#### 1. 메모리를 효율적으로 관리할 수 있다.
    
문자의 경우 한 글자마다 차지하는 용량이 가변적(영어는 1바이트 한글은 2바이트 등)인데 데이터를 저장할 공간을 따로 두지않고 변수의 공간에 같이 저장할 경우 문자가 변경될 때마다 문자열의 크기에 맞춰 확보된 공간을 늘려야한다. 데이터 저장 공간이 중간에 위치해 있다면 뒤에 저장된 데이터를 뒤로 옮기는 연산을 수행해야 한다.

하지만 따로 둘 경우 abc에서 def를 추가해 abcdef를 변수에 할당할 때 abc가 저장된 데이터 공간은 그대로 두고 abcdef 문자열을 새로 만들어 별도의 공간에 저장하고 변경된 주소를 변수 공간에 연결한다. 데이터를 변경할 때마다 불필요한 연산을 수행할 필요가 없어 컴퓨터 입장에서 부담이 줄어든다.

#### 2. 중복된 데이터 처리 효율이 높아진다.

변수 50개를 선언하고 값을 0으로 초기화하는 경우, 0을 임의의 공간에 할당하고 그 주소를 50개의 변수가 참조하면 되기 때문에 중복을 처리하는 데 불필요한 데이터가 낭비되지 않는다.

***

### 2.4 불변값

기본형 데이터는 모두 불변값이다.

변수와 상수를 결정하는 것은 **변수 영역의 메모리를 변경할 수 있는 지의 여부**이고, 가변성과 불변성을 결정짓는 것은 **데이터 영역의 메모리를 변경할 수 있는 지의 여부**이기 때문에 상수와 불변성은 다른 것이다.

```javascript
var a = 'abc';
a += 'def';

var b = 5;
var c = 5;
b = 7;
```

1. a의 경우
    - a에 할당된 데이터 'abc' 자체가 변경되는 것이 아니라 'abcdef'라는 새로운 데이터를 생성하고 그 주소를 a에 저장한다.
2. b의 경우
    - 데이터 영역에서 5를 찾는다.
    - 5가 없으면 새로 만들어 5를 저장한 주소를 변수에 할당한다.
3. c의 경우
    - 데이터 영역에서 5를 찾는다.
    - 이미 5가 존재하기 때문에 그 주소를 c에 할당한다.
4. b의 데이터를 변경하는 경우
    - b에 할당된 5가 7로 변경되는 것이 아니라 데이터 영역에 7이 있다면 재활용하고 없다면 새로 만들어 b에 저장된 주소 값을 바꾼다.

이처럼 변수에 담긴 데이터는 다른 값으로 바꿀 수 없다. 변경하는 작업은 새로 만드는 동작을 통해서만 이루어진다. 이것이 **불변값의 성질**이다.

***

### 2.5 가변값

참조형 데이터는 기본적으로 가변값이지만 설정에 따라 변경 불가능한 경우도 있고, 아예 불변값으로 활용하는 방법도 있다.

#### 2.5.1 참조형 데이터 변수 할당 과정

```javascript
var obj = {
    num: 1,
    str: 'aaa'
};
```

1. 메모리에서 빈 공간 @1002를 확보하고 이름을 obj로 지정한다,
2. 임의의 데이터 공간(@5002)에 값을 저장하려고 보니 여러 개의 프로퍼티(변수)로 이루어진 데이터 그룹이다. 프로퍼티(변수)들을 저장하기 위해 별도의 변수 영역(@7002 ~ ?)을 확보하고, 그 영역의 주소를 @5002에 저장한다.
3. 별도의 변수 영역(@7002 ~ ?)에 각각 num과 str이라는 프로퍼티(변수) 이름을 지정한다.
4. 데이터 영역에 1, aaa가 있는 지를 검색하고 없으면 임의의 주소(@5003, @5004)에 저장하고 그 주소값을 변수 영역(@7002 ~ ?)에 저장한다.

***

#### 2.5.2 참조형 데이터 프로퍼티 재할당

```javascript
var obj = {
    num: 1,
    str: 'aaa'
};

obj.num = 2;
```

1. 데이터 영역에서 2가 저장되어 있는 지 검색한다.
2. 없으면 임의의 주소(@5005)에 새로 만들고 이 주소값을 num 프로퍼티(변수)가 있는 @7002에 저장한다.

변수 obj가 바라보고 있는 주소는 @5002로 변하지 않았다. 즉, 새로운 객체가 만들어진 것이 아니라 기존 객체에서 내부 값만 변경된 것을 뜻한다.

참조형 데이터는 프로퍼티(변수) 영역이 따로 존재하고, 값이 저장되어 있는 주소값은 프로퍼티(변수) 영역에 저장된다. 데이터 영역이 저장하고 있는 프로퍼티(변수)의 주소값은 변경되지 않지만, 프로퍼티(변수)가 저장하고 있는 데이터의 값은 변경 가능하기 때문에 불변하지 않다(가변값이다)라고 한다.

***

#### 2.5.3 중첩된 참조형 데이터 할당

```javascript
var obj = {
    num: 1,
    arr: [3, 4, 5]
};
```

1. 임의의 빈 공간(@1002)을 확보하고 이름을 obj로 지정한다.
2. 데이터를 저장하려고 보니 여러 개의 프로퍼티(변수)로 이루어진 데이터 그룹이다. 임의의 변수 영역(@7002 ~ ?)들을 확보하고 주소값을 임의의 주소(@5002)에 저장한다.
3. 1이 저장되어 있다면 재활용하고 아니면 새로 만든 뒤(@5003) 그 주소값을 @7002에 저장한다.
4. @7003 arr의 데이터를 저장하려고 보니 여러 개의 데이터를 가진 데이터 그룹이다. 각각의 데이터를 저장할 변수 영역(@8002 ~ ?)을 확보하고 주소값을 임의의 주소(@5004)에 저장하고 @7003에 @5004를 저장한다.
5. @8002 ~ ?에 각각의 인덱스 번호를 부여한다.
6. 3, 4, 5를 검색하고 없으면 새로 만들어 @8002 ~ ?에 저장한다.

#### 2.5.4 obj.arr[1] 값 가져오기

1. obj를 검색하고 obj에 저장된 주소 @5002로 이동한다.
2. 저장된 값이 주소이므로 그 주소(@7002 ~ ?)로 이동한다.
3. 주소로 이동해 arr이 있는 곳으로 이동한다.
4. 값이 주소이므로 그 주소(@5004)로 이동한다.
5. 값이 주소이므로 그 주소(@8002 ~ ?)로 이동한다.
6. 인덱스 1을 검색해 이동한다.
7. 인덱스 1이 가지고 있는 주소로 이동해 4를 가져온다.

> @1002 -> @5002 -> @7002 ~ ? -> @7003 -> @5004 -> @8002 ~ ? -> @8003 -> @5006 -> 4반환

***

#### 2.5.5 변수 복사 비교

기본형 데이터 변수 복사  

```javascript
var a = 10;
var b = a;
```

1. 임의의 빈 공간(@1001)을 할당하고 이름을 a로 지정한다.
2. 10이 저장되어 있는 지 검색하고 없다면 임의의 공간(@5001)에 저장한다.
3. @5001을 @1001에 저장한다.
4. 임의의 빈 공간(@1002)을 할당하고 이름을 b로 지정한다.
5. a를 검색하고 그 값인 @5001을 @1002에 저장한다.

참조형 데이터 변수 복사

```javascript
var obj1 = {
    num: 10,
    str: 'ddd'
};
var obj2 = obj1;
```

1. 임의의 빈 공간(@1003)을 할당하고 이름을 obj1로 지정한다.
2. 프로퍼티의 주소를 저장할 임의의 빈 공간(@5002)을 할당하고 프로퍼티의 공간을 할당(@7001 ~ ?)한 뒤 그 주소 값을 저장한다.
3. @7001, @7002의 이름을 각각 num, str로 지정한다.
4. 10이 저장되어 있는 지 검색하고 이미 존재하기 때문에 그 주소 값(@5001)을 @7001에 저장한다.
5. ddd를 임의의 공간(@5003)에 저장하고 그 주소를 @7002에 저장한다.
6. 임의의 빈 공간(@1004)을 할당하고 이름을 obj2로 지정한다.
7. obj1을 검색하고 변수의 값인 @5002를 @1004에 저장한다.

복사 과정은 기본형과 참조형 모두 동일하지만 데이터 할당 과정에서 차이가 있기 때문에 변수 복사 이후 동작에 큰 차이가 발생한다.

***

프로퍼티 변경

```javascript
var a = 10;
var b = a;

var obj1 = {
    num: 10,
    str: 'ddd'
};
var obj2 = obj1;

b = 15;
obj2.num = 20;
```

1. 15를 검색하고 없으면 임의의 공간(@5004)에 저장하고 그 주소를 @1002에 저장한다. (b의 값이 변경된다.)

1. 20을 검색하고 없으면 임의의 공간(@5005)에 저장하고 그 주소를 가지고 obj2를 검색하고(@1004) obj2의 값인 @5002에서 @7001 ~ ?로 이동해 num을 검색하고 num이 가리키는 주소값을 @5005로 바꾼다. (obj2의 값이 변경되지 않는다.)

기본형 데이터의 경우 변수가 가지고 있는 값이 달라진 반면 참조형의 경우 프로퍼티의 값만 변경되었을 뿐 변수의 값은 변경되지 않았다.

obj2가 가지고 있는 num 프로퍼티의 값을 변경하는 경우 obj1의 num 프로퍼티 값까지 변경된다.

**이것이 기본형 데이터와 참조형 데이터의 가장 큰 차이점이다.**

***

객체 자체를 변경하였을 때

```javascript
var a = 10;
var b = a;

var obj1 = {
    num: 10,
    str: 'ddd'
};
var obj2 = obj1;

b = 15;
obj2 = {
    num: 20,
    str: 'ddd'
};
```

참조형 데이터에 새로운 객체를 선언해 할당하는 경우 메모리에 새로운 객체가 저장되고 그 주소를 변수 obj2 위치에 저장한다.

참조형 데이터 임에도 변수가 가지고 있는 값이 달라졌다.

이를 통해 가변값의 성질은 프로퍼티를 변경할 때만 성립하고, 데이터 자체를 변경하는 경우에는 성립하지 않는다는 사실을 알 수 있다.

***

#### 2.5.6 불변 객체 만들기

참조형 데이터의 가변은 내부 프로퍼티를 변경할 때 적용되고, 데이터 자체를 변경할 때는 적용되지 않는다.

이러한 특성을 이용해 복사한 데이터의 프로퍼티가 변경되어도 원본 객체의 프로퍼티는 그대로 유지되는 불변 객체를 만들 수 있다.

불변성을 확보해야 하는 경우에는 객체를 복사할 때 새로운 객체를 생성해 할당하도록 구성한다.

```javascript
var copyObject = function(target) {
    var result = {};

    for (var prop in target) {
        result[prop] = target[prop];
    }

    return result;
}

var user = {
    name: 'Seonghun',
    gender: 'male'
};

var user2 = copyObject(user);
user2.name = 'Hong';

console.log(user.name, user2.name);  // Seonghun Hong
```

객체의 프로퍼티를 모두 복사해 새로운 객체를 생성한 후 그 객체를 리턴해주는 copyObject 함수를 구성한다.

copyObject 함수를 사용해 객체를 복사하면 복사한 객체에서 프로퍼티를 변경하여도 원본 객체의 프로퍼티는 그대로 유지된다는 것을 알 수 있다.

***

#### 2.5.7 얕은 복사와 깊은 복사

위 copyObject 함수를 사용해 중첩된 객체를 복사하는 경우 사본의 중첩 객체의 프로퍼티를 변경하면 원본의 프로퍼티도 변경된다는 문제가 있다.

```javascript
var user = {
    name: 'Seonghun',
    details: {
        address: 'Masan',
        number: '010-1234-5678',
        gender: 'Male'
    }
};
var user2 = copyObject(user);
user2.name = 'Hong'
user2.details.address = 'Busan';

console.log(user.name, user2.name);    // Seonghun Hong
console.log(user.details.address, user2.details.address);    // Busan Busan
```

즉 user 객체에 직접 속한 프로퍼티의 경우 완전히 새로운 데이터가 생성되었지만, user 내부의 details 객체의 경우 기존 데이터의 주소를 그대로 참조한다.

이를 얕은 복사라 한다.

***

**깊은 복사**

복사할 객체 내부에 객체가 존재한다면 그 객체도 새로운 데이터로 생성되도록 재귀적으로 함수를 구현한다.

```javascript
var deepCopyObject = function(target) {
    var result = {};

    if (typeof target === 'object' && target !== null) {
        for (var prop in target) {
            result[prop] = deepCopyObject(target[prop]);
        }
    } else {
        result = target;
    }

    return result;
}

var user = {
    name: 'Seonghun',
    details: {
        address: 'Masan',
        number: '010-1234-5678',
        gender: 'Male'
    }
};
var user2 = deepCopyObject(user);
user2.name = 'Hong'
user2.details.address = 'Busan';

console.log(user.name, user2.name);    // Seonghun Hong
console.log(user.details.address, user2.details.address);    // Masan Busan
```

deepCopyObject 함수를 통해 객체를 복사한 경우 객체의 내부 객체까지 새로운 데이터를 생성해 할당하기 때문에 사본에서의 프로퍼티 변경이 원본에 영향을 미치지 않는다.

이를 깊은 복사라 한다.

*** 

### 2.6 undefined 와 null

undefined와 null 모두 자바스크립트에서 '없음'을 나타내는 값이다.

### 2.6.1 undefined

자바스크립트에서 값이 undefined인 경우는 두 가지로 나눌 수 있다.

1. 사용자가 명시적으로 값을 undefined로 지정한 경우
2. 자바스크립트 엔진이 자동으로 부여하는 경우
    - 값을 대입하지 않은 변수
    - 객체 내부의 존재하지 않는 프로퍼티에 접근하려 할 때
    - return 문이 없거나 호출되지 않는 함수의 실행 결과

```javascript
var a;
console.log(a); // undefined

var obj = { a: 1 };
console.log(obj.a); // 1
console.log(obj.b); // undefined

var func = function() {}
var c = func();  // 반환 값이 없으면 undefined를 반환한 것으로 간주
console.log(c);  // undefined
```

배열을 선언하고 값을 대입하지 않은 경우는 위와 다르게 동작한다.

```javascript
var arr1 = [];
arr1.length = 3;
console.log(arr1);  // [empty × 3]

var arr2 = new Array(3);
console.log(arr2);  // [empty × 3]

var arr3 = [undefined, undefined, undefined];
console.log(arr3)   // [undefined, undefined, undefined]
```

이처럼 비어있는 요소와 undefined를 할당한 요소는 출력 결과부터 다른 것을 알 수 있다. 비어있는 요소의 경우 순회와 관련된 배열 메서드의 순회 대상에서 제외된다.

```javascript
var arr1 = [undefined, 1];
var arr2 = [];
arr2[1] = 1;

arr1.forEach((v, i) => { console.log(v, i); }); // undefined 0 / 1 1
arr2.forEach((v, i) => { console.log(v, i); }); // 1 1

arr1.map((v, i) => v + i);  // [NaN, 2]
arr2.map((v, i) => v + i);  // [empty, 2]

arr1.filter(v => !v);   // [undefined]
arr2.filter(v => !v);   // []

arr1.reduce((p, c, i) => p + c + i, '');    // "undefined011"
arr2.reduce((p, c, i) => p + c + i, '');    // "11"
```

arr2의 0번 인덱스에 값을 추가하지 않았더니 배열을 순회하는 메서드들이 아무런 작업도 수행하지 않고 1번 인덱스로 건너뛴 것을 알 수 있다.

배열도 객체와 같이 특정 인덱스에 값이 저장되면 그때 빈 공간을 할당해 값을 저장하기 때문에 이러한 현상이 발생한다. 즉 값이 지정되지 않은 프로퍼티는 아직 존재하지 않는 프로퍼티이기 때문에 이러한 현상이 발생함을 알 수 있다.

**사용자가 직접 지정하는 undefined와 자바스크립트 엔진이 반환하는 undefined의 차이**

1. 사용자가 직접 지정하는 경우: undefined 자체가 값이다. 변수, 프로퍼티, 키값이 실존하고 데이터 값이 undefined이다.
2. 자바스크립트 엔진이 반환하는 경우: 변수, 프로퍼티, 키값 자체가 존재하지 않음을 의미한다. 

즉 값으로써의 undefined는 어딘가에 존재하는 데이터인 반면 자바스크립트 엔진이 반환하는 undefined는 문자 그대로 값이 없음을 나타낸다.

### 2.6.2 null

undefined는 사용하는 방식에 따라 의미하는 바가 달라 혼란을 야기할 수 있다. 이 문제를 해결하는 방법은 undefined가 해당되는 경우는 자바스크립트가 반환하는 경우만 존재하도록 두면된다. 즉 변수에 직접 undefined를 할당하지 않는다.

null은 '비어있음'을 명시적으로 나타내기 위해 만들어진 데이터 타입으로 '비어있음'을 명시적으로 나타내야 하는 상황이 생긴다면 null을 사용하면 되겠다.

null은 주의사항이 하나 있는데 바로 typeof null이 object라는 것이다. 이는 자바스크립트 자체 버그이다. 따라서 어떤 변수의 값이 null인지 알아내기 위해서는 typeof 대신 다른 방법을 사용해야 한다.

```javascript
var n = null;
console.log(typeof n);   // object

console.log(n == undefined);   // true
console.log(n == null);    // true
console.log(n === undefined);   // false
console.log(n === null);    // true
```

동등 연산자(==)를 사용하면 null과 undefined가 같다고 판단한다. 따라서 변수가 null인지 판단하기 위해서는 일치 연산자(===)를 사용해야 한다.
